## **1. Key components in memory interfacing with a microcontroller**

**Introduction:**
Memory interfacing means connecting external memory chips (RAM/ROM) to a microcontroller so they can exchange data.

**Main Explanation (components + function):**

1. **Address Bus** → Carries the memory address (location of data).
2. **Data Bus** → Transfers actual data (read/write).
3. **Control Lines** → Decide the operation:

   * **RD (Read)** → tells memory to send data.
   * **WR (Write)** → tells memory to store data.
   * **CS (Chip Select)** → activates the correct memory chip.

**Conclusion:**
In short, memory interfacing needs **Address bus (where), Data bus (what), and Control lines (how)**.

---

## **2. States of a task in an RTOS + transitions**

**Introduction:**
A Real-Time Operating System (RTOS) manages tasks, each of which can be in different states.

**States + Transition Events:**

1. **Ready** → Task waiting for CPU.

   * Transition: moves to **Running** when scheduler gives CPU.
2. **Running** → Task currently executing.

   * Transition: moves back to **Ready** if preempted.
3. **Blocked/Waiting** → Task paused, waiting for event (I/O, signal).

   * Transition: moves to **Ready** when event occurs.

**Conclusion:**
RTOS tasks cycle between **Ready → Running → Blocked** depending on CPU scheduling and external events.

---

## **3. Memory organization (8051 internal vs external) + EA pin**

**Explanation:**

* **Internal Program Memory:**

  * Up to **4 KB ROM** inside 8051. Fast access.
* **External Program Memory:**

  * Up to **64 KB external ROM/EPROM** can be connected.

**EA Pin (External Access):**

* **EA = 1 (High):** use **internal program memory first**, external only if beyond 4KB.
* **EA = 0 (Low):** force CPU to fetch program from **external memory only**.

**Conclusion:**
Internal is small but faster; external is large but slower. **EA decides source.**

---

## **4. General-Purpose OS vs Real-Time OS**

**General-Purpose OS (e.g., Windows/Linux):**

* Focus: throughput, multitasking, user-friendly.
* Example: Playing music + browsing internet.

**RTOS (e.g., FreeRTOS, VxWorks):**

* Focus: **timing & deadlines**.
* Example: Airbag deployment, medical devices.

**Conclusion:**
Difference = **performance vs predictability**. RTOS ensures deadlines, GP-OS ensures user features.

---

## **5. Basic structure of an Embedded C program**

**Components:**

1. **Preprocessor Directives** → include libraries (`#include <reg51.h>`).
2. **Global Declarations** → variables, constants.
3. **main() function** → starting point; runs program logic.
4. **Functions** → modular code blocks for readability.

**Conclusion:**
Every Embedded C program has **directives + main() + logic**.

---

## **6. Control lines in LCD interfacing (Enable, RW, RS)**

* **RS (Register Select):** 0 = command register, 1 = data register.
* **RW (Read/Write):** 0 = write to LCD, 1 = read from LCD.
* **E (Enable):** A high-to-low pulse tells LCD to “accept” command/data.

**Conclusion:**
RS selects mode, RW chooses direction, E latches data.

---

## **7. Embedded C code snippet to send a character to LCD**

```c
#include <reg51.h>
sbit RS = P2^0;
sbit RW = P2^1;
sbit EN = P2^2;

void lcd_command(char cmd) {
  RS = 0; RW = 0; P1 = cmd;
  EN = 1; EN = 0;
}

void lcd_data(char dat) {
  RS = 1; RW = 0; P1 = dat;
  EN = 1; EN = 0;
}

void main() {
  lcd_data('A');   // Sends character 'A' to LCD
  while(1);
}
```

**Conclusion:**
Use `lcd_data()` function with RS=1, RW=0, and EN pulse to send a character.

---

## **8. CPU Utilization (Rate Monotonic Scheduling)**

Formula:

$$
U = \sum (C_i / T_i)
$$

where $C_i$ = computation time, $T_i$ = period.

If $ U \leq n(2^{1/n}-1)$, system is schedulable.

**Conclusion:**
Utilization depends on ratio of burst time/period for all tasks.

---

## **9. Context switching scenario**

Steps when switching between Task A and Task B:

1. Save current task’s CPU registers, PC, SP.
2. Store in task control block (TCB).
3. Load new task’s TCB (registers, PC, SP).
4. Resume execution from saved state.

**Conclusion:**
Context switch = **save old → load new**.

---

## **10. Keyboard interfacing circuit**

* Arrange keys in **matrix (Rows × Columns)**.
* Rows connected to microcontroller outputs.
* Columns connected to inputs with pull-up resistors.
* MCU scans rows and detects pressed key by column change.

**Conclusion:**
Matrix saves pins and is scanned row-by-row.

---

## **11. Scheduling to prevent priority inversion**

Use **Priority Inheritance Protocol (PIP):**

* If low-priority task holds resource needed by high-priority task → temporarily “inherit” high priority until resource is released.

**Conclusion:**
PIP avoids blocking of high-priority tasks.

---

## **12. Addressing modes in 8051 for external memory**

* **External Program Memory:**

  * `MOVC A, @A+DPTR`
  * `MOVC A, @A+PC`
* **External Data Memory:**

  * `MOVX A, @DPTR`
  * `MOVX @DPTR, A`

**Conclusion:**
MOVC → code memory; MOVX → external data memory.

---

## **13. Cyclostatic vs Round Robin Scheduling**

* **Cyclostatic:** Static, pre-planned schedule, very predictable → used in multimedia streaming.
* **Round Robin:** Equal time slices, fair sharing, not always deadline-guaranteed.

**Conclusion:**
Cyclostatic = predictable; RR = simple, fair.

---

## **14. RTOS vs Bare-metal programming**

* **RTOS:** Easy multitasking, modular, but overhead and needs more memory.
* **Bare-metal:** Fast, minimal, but hard to manage multiple tasks.

**Example:**

* RTOS → drone autopilot.
* Bare-metal → simple temperature sensor.

---

## **15. Handling priority inversion**

**Solution:** Priority Inheritance or Priority Ceiling.

* Blocked high-priority task temporarily “lends” its priority to the low task holding resource.
